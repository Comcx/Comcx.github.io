#+Title:  From Recursion to Greedy algorithms: a functional perspective
#+Author: Comcx
#+Date:   <2020-01-22 三>


There's an important leanring and developing chain of traditional algorithms:

=Divide and Conquer(recursion) ---> Dynamic Programming(mermorization) --> Greedy= 


This chain(route) is also quite suitble to get to think and solve a problem.
We may think problems in this way, but I sometimes just get confused if I insist on
following the rule. To collect our thinkings, programming languages play an really important role
in problem solving. Functional programming languages often work better for thinking but sometimes hard
to implement as efficiently as others. In fact, functional programming languages can also be very efficient
with careful implementation. As a programmer, we should get used to think in a more functional way and also,
be good at translate functional programs into other languages.


** Functional Programming とは ...
A functional programming language should have the following features:

1) Functions are first-class and thus can be passed as high-order function values.
2) Functions can be constructed without any side-effect.
3) Have both evaluation strategies: eager and lazy.


A functional programming language may have the following features:

1) Static and strict type system
2) Type polymorphism(type as type parameters)
3) Typeclass or trait(OO) system(u can also regard as structured overloading)
4) Pure without any side-effect(which means u can not survivie without monad:)
5) Dependent Typed System


** Divide and Conquer
Before starting to explore recursions, let us first reflect some questions:

1. What is data structure and what is a algorithm?
2. Any links between data structure and algorithms?
3. What kind of algorithm should we use for different kinds of data structures?


*** Data structures by examples
In functional world, a very common and heavy used data structure is *List a(or [a] in haskell)*.
Let's look at its definition first:
#+BEGIN_SRC haskell

data List a = Nil | Cons a (List a)
#+END_SRC
If we regard that =List= is just a function which receive a type and output a type, then we can rewrite
the definition(this is not strict...):
#+BEGIN_SRC 
List :: (a :: Type) -> Type where
  Cons :: a -> List a -> List a
  Nil  :: List a
#+END_SRC
We just defined 3 functions, this can be easily done with dependent typed languages.
For a simple list: =[1, 2, 3],= we can simply write it done:
#+BEGIN_SRC 
(Cons 1 (Cons 2 (Cons 3 Nil)))
#+END_SRC
Now we just replace all =Cons= into =(+)= and =Nil= into =0=.
#+BEGIN_SRC 
((+) 1 ((+) 2 ((+) 3 0))) => 1 + 2 + 3 + 0 => 6
#+END_SRC
We just turned a unfoldable(terminated form) into a foldable expression!
You may see that List is a prototype of many expressions, we can use this abstracted data structure
to generate more expressions without actually writing them character after charater!

Now define a replacing function:
#+BEGIN_SRC 
replace f a (Cons x xs) = f x (replace f a xs)
replace f a Nil = a
#+END_SRC
In fact, this function is called =foldr= in Haskell.

*** Expressions
In the last part, we talked about data structures. However, a new question raised that,
What exactly is an expression??

Let's first get a simple definition.
#+BEGIN_SRC 
An expression is any valid unit of code that resolves to a value.
#+END_SRC
Well, this looks still not enough straight-forward answer.
If so, then what is value??

Before we have the ability and knowledge to answer these questions, let's firstly introduce some
necessary terminologies.

- *Thunk*
#+BEGIN_SRC 
A thunk is another name for the function(but the special one).
It's a function yet to be evaluated.
For example, in Haskell, every expression is lazy and be stored into a thunk.
#+END_SRC

- Beta reduction
#+BEGIN_SRC 
Beta reduction is a process of calculating result of a function after function application.
We can now simple regard this process as a special replacing of introduced local variables.
#+END_SRC

Ok! Now let's explore it! What is a value?
Firstly I guess /value/ is the form that can not be calculated further.

*Definition of Redeuced Normal Form(RNF)* 
#+BEGIN_SRC 

#+END_SRC


** Dynamic Programming


** Greedy





